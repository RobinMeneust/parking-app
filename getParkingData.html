<!DOCTYPE html>
<html>
<head>
</head>
<body>
	

</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
	<title>Accueil</title>
	<meta charset="UTF-8">
</head>
<body>
	<button id="getUserLocation">Trouver des parkings proches de votre position</button>
	<table id="tableParkings">
	</table>
	<script>	
		function addTd(tr, content){
			var td = document.createElement('td');
			td.innerHTML = content;
			tr.appendChild(td);
		}
		function addTh(tr, content){
			var th = document.createElement('th');
			th.innerHTML = content;
			tr.appendChild(th);
		}

		function distMeters(lat1, lon1, lat2, lon2){
			//src : https://en.wikipedia.org/wiki/Haversine_formula
			const R = 6371e3; // Earth radius

			// Convert degrees to radians
			const phi1 = lat1 * Math.PI/180;
			const phi2 = lat2 * Math.PI/180;
			
			// Get lat and lon variation in radians
			const dphi = (lat2-lat1) * Math.PI/180;
			const dlambda = (lon2-lon1) * Math.PI/180;

			// Haversine function
			const h = Math.sin(dphi/2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * (Math.sin(dlambda/2) ** 2);
			
			// Distance in meters = (Inverse haversine of h) * r = 2 * r * arcsin(sqrt(h))
			return 2 * R * Math.asin(Math.sqrt(h));
		}

		function getCapacity(data, surface){
			/*
			Surface -> capacity : https://www.dimensions.com/element/90-degree-parking-spaces-layouts
			400m² -> 12 slots
			*/
			let capacity = {value:0, approx:false};

			if(data.hasOwnProperty('capacity')){
				capacity.value = parseInt(data.capacity);
			}else{
				capacity.value = surface * (3/100);
				capacity.value = Math.round(capacity.value);
				capacity.approx = true;
			}
			if(capacity.value < 0){
				capacity.value = 0;
			}
			return capacity
		}

		function getFee(data){
			if(data.hasOwnProperty('fee')){
				return data.fee;
			} else{
				return ""
			}
		}

		function getPaymentMethod(data){
			let payment = {cash:"", credit_card:"", coins:""}
			if(data.hasOwnProperty('payment:cash')){
				payment.cash = data['payment:cash'];
			}
			if(data.hasOwnProperty('payment:credit_card')){
				payment.cash = data['payment:credit_card'];
			}
			if(data.hasOwnProperty('payment:coins')){
				payment.cash = data['payment:coins'];
			}
			return payment;
		}

		async function getAddressFromPos(pos){
			const response = await fetch("https://api.opencagedata.com/geocode/v1/json?q="+pos.lat+"+"+pos.lon+"&key=6ed462e0c4a54f39a14230ff783fc470")
			const json = await response.json();
			return json.results[0].formatted;
		}

		async function getParkingsData(latitude, longitude){
			//let searchPos = {lat:49.023079,lon:2.047221};
			let searchPos = {lat:latitude,lon:longitude};
			let searchRadius = 600;
			
			let url = 'http://overpass-api.de/api/interpreter?data=[out:json];(way[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');relation[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');node[amenity=parking][capacity](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+'););out bb;';
			let data = [];
		
			try{
				const response = await fetch(url)
				const out = await response.json();
				console.log(out);
				
				for(let element in out.elements){
					let parking = {
						capacity:{value:0,approx:true}, 
						fee:getFee(out.elements[element].tags), 
						surface:0, 
						address:"",
						distance:0,
						pos:{lat:0.0,lon:0.0},
						paymentMethod:{cash:"", credit_card:"", coins:""}
					};
					
					let tr = document.createElement('tr');
					if(out.elements[element].type != "node"){
						let lonDiff = out.elements[element].bounds.maxlon -out.elements[element].bounds.minlon;
						let latDiff = out.elements[element].bounds.maxlat -out.elements[element].bounds.minlat;
						parking.pos.lat = (out.elements[element].bounds.maxlat + out.elements[element].bounds.minlat) / 2;
						parking.pos.lon = (out.elements[element].bounds.maxlon + out.elements[element].bounds.minlon) / 2;
						
						let lat1 = parking.pos.lat;
						let lat2 = searchPos.lat;
						let lon1 = parking.pos.lon;
						let lon2 = searchPos.lon;

						let latWidth = distMeters(out.elements[element].bounds.minlat, out.elements[element].bounds.minlon, out.elements[element].bounds.maxlat, out.elements[element].bounds.minlon);
						let lonWidth = distMeters(out.elements[element].bounds.minlat, out.elements[element].bounds.minlon, out.elements[element].bounds.minlat, out.elements[element].bounds.maxlon);
						parking.surface = latWidth * lonWidth;
					}
					else{
						parking.pos.lat = out.elements[element].lat;
						parking.pos.lon = out.elements[element].lon;
					}
					parking.paymentMethod = getPaymentMethod(out.elements[element].tags);
					parking.capacity = getCapacity(out.elements[element].tags, parking.surface);
					parking.address = await getAddressFromPos(parking.pos);
					parking.distance = distMeters(parking.pos.lat, parking.pos.lon, searchPos.lat, searchPos.lon);
					data.push(parking);
				}
				return data;
			}
			catch(error){
				console.log("Error: could not fetch and parse data");
			}
		}
		
		function createTable(data){
			let table = document.getElementById("tableParkings");
			let tr = document.createElement('tr');
			addTh(tr, "adresse");
			addTh(tr, "nombre de places max");
			addTh(tr, "distance");
			addTh(tr, "payant");
			addTh(tr, "paiement en carte de crédit");
			addTh(tr, "paiement en billets");
			addTh(tr, "paiement en pièces");
			table.appendChild(tr);
			
			for(let element in data){
				let tr = document.createElement('tr');
				addTd(tr, data[element].address);
				addTd(tr, (data[element].capacity.approx ? "~":"") + data[element].capacity.value);
				addTd(tr, data[element].distance);
				addTd(tr, data[element].fee);
				addTd(tr, data[element].paymentMethod.credit_card);
				addTd(tr, data[element].paymentMethod.cash);
				addTd(tr, data[element].paymentMethod.coins);
				table.appendChild(tr);
			}
		}

		let button = document.getElementById("getUserLocation");
		let latText = document.getElementById("latitude");
		let longText = document.getElementById("longitude");
		
		button.addEventListener("click", () => {
			navigator.geolocation.getCurrentPosition((position) => {
				let lat = position.coords.latitude;
				let lon = position.coords.longitude;
				getParkingsData(lat,lon).then((data) => {
					console.log(data);
					createTable(data);
				})
			});
		});
		
		// Used to get predict the number of free slots
		/*
		searchPos.lat=49.0101759;
		searchPos.lon=2.0421101; 

		url = 
		'http://overpass-api.de/api/interpreter?data='
		+'[out:json];'
		+'(node[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
		+'node[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
		+'node[amenity="place_of_worship"](around:500,49.0101759,2.0421101);'
		+'node[shop](around:500,49.0101759,2.0421101);'
		+'node[airway="airport"](around:500,49.0101759,2.0421101);'
		+'node[healthcare](around:500,49.0101759,2.0421101);'
		+'node[historic](around:500,49.0101759,2.0421101);'
		+'node[leisure](around:500,49.0101759,2.0421101);'
		+'node[office](around:500,49.0101759,2.0421101);'
		+'node[tourism](around:500,49.0101759,2.0421101);'
		+'way[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
		+'way[amenity="place_of_worship"](around:500,49.0101759,2.0421101);'
		+'way[shop](around:500,49.0101759,2.0421101);'
		+'way[airway="airport"](around:500,49.0101759,2.0421101);'
		+'way[healthcare](around:500,49.0101759,2.0421101);'
		+'way[historic](around:500,49.0101759,2.0421101);'
		+'way[leisure](around:500,49.0101759,2.0421101);'
		+'way[office](around:500,49.0101759,2.0421101);'
		+'way[tourism](around:500,49.0101759,2.0421101););out;';
		
		fetch(url)
		.then((res) => res.json())
		.then((out) => {
			console.log(out);
			let probabilityFull = 0.0;
		})
		.catch(error => { throw error });
		*/
		/*
		- Create a variable that will start at 0 and increase if the probability that the parking is full increase. It'll be influenced by the following elements :
		- Display the accuracy of the prediction (e.g by using capacity.approx) ?
		- Get traffic data and/or city density -> nominatim (density) & TomTom (traffic)
		- Get current time and adjust the coefficients of the nodes and ways got just before (ex at night college will have a smaller weight and bar a higher one; in summer tourism will have a higher weight during holidays...)-
		- Check if there are other parkings nearby (it'll lower the probability, -> divide it by the quantity of parkings, or their capacity?)
		*/
		
	</script>
	
	</body>
	</html>
	