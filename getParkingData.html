<!DOCTYPE html>
<html>
<head>
</head>
<body>
	

</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
	<title>Accueil</title>
	<meta charset="UTF-8">
</head>
<body>
	<button id="getUserLocation">Trouver des parkings proches de votre position</button>
	<input id="searchBox" type="text" value="Paris 1er Arrondissement"></input>
	<button id="getSearchParams">Chercher un département ou une région entrée</button>
	<button onclick="testFreeSlotSim()">Test simulation emplacements libres</button>
	<table id="tableParkings">
	</table>
	<script>	
		function addTd(tr, content){
			var td = document.createElement('td');
			td.innerHTML = content;
			tr.appendChild(td);
		}
		function addTh(tr, content){
			var th = document.createElement('th');
			th.innerHTML = content;
			tr.appendChild(th);
		}

		function distMeters(lat1, lon1, lat2, lon2){
			//src : https://en.wikipedia.org/wiki/Haversine_formula
			const R = 6371e3; // Earth radius

			// Convert degrees to radians
			const phi1 = lat1 * Math.PI/180;
			const phi2 = lat2 * Math.PI/180;
			
			// Get lat and lon variation in radians
			const dphi = (lat2-lat1) * Math.PI/180;
			const dlambda = (lon2-lon1) * Math.PI/180;

			// Haversine function
			const h = Math.sin(dphi/2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * (Math.sin(dlambda/2) ** 2);
			
			// Distance in meters = (Inverse haversine of h) * r = 2 * r * arcsin(sqrt(h))
			return 2 * R * Math.asin(Math.sqrt(h));
		}

		function getCapacity(data, surface){
			/*
			Surface -> capacity : https://www.dimensions.com/element/90-degree-parking-spaces-layouts
			400m² -> 12 slots
			*/
			let capacity = {value:0, approx:false};

			if(data.hasOwnProperty('capacity')){
				capacity.value = parseInt(data.capacity);
			}else{
				capacity.value = surface * (3/100);
				capacity.value = Math.round(capacity.value);
				capacity.approx = true;
			}
			if(capacity.value < 0){
				capacity.value = 0;
			}
			return capacity
		}

		function getFee(data){
			if(data.hasOwnProperty('fee')){
				return data.fee;
			} else{
				return ""
			}
		}

		function getPaymentMethod(data){
			let payment = {cash:"", credit_card:"", coins:""}
			if(data.hasOwnProperty('payment:cash')){
				payment.cash = data['payment:cash'];
			}
			if(data.hasOwnProperty('payment:credit_card')){
				payment.cash = data['payment:credit_card'];
			}
			if(data.hasOwnProperty('payment:coins')){
				payment.cash = data['payment:coins'];
			}
			return payment;
		}

		async function getAddressFromPos(pos){
			const response = await fetch("https://api.opencagedata.com/geocode/v1/json?q="+pos.lat+"+"+pos.lon+"&key=6ed462e0c4a54f39a14230ff783fc470")
			const json = await response.json();
			return json.results[0].formatted;
		}

		async function getParkingsData(latitude, longitude, areaParams){
			//let searchPos = {lat:49.023079,lon:2.047221};
			let searchPos = {lat:latitude,lon:longitude};
			let searchRadius = 600;
			
			// We only take nodes with the capacity tag because we don't have borders to get an surface used to get an approximation of this capacity

			let url ='';
			if(areaParams==""){
				url = 'https://overpass-api.de/api/interpreter?data=[out:json];(way[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');relation[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');node[amenity=parking][capacity](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+'););out bb 200;';
			}
			else{
				url = 'https://overpass-api.de/api/interpreter?data=[out:json];('+areaParams+'way[amenity=parking](area);relation[amenity=parking](area);node[amenity=parking][capacity](area););out bb 200;';
			}
			
			let data = [];
		
			try{
				const response = await fetch(url)
				const out = await response.json();
				let nbParkings = out.elements.length;
				if(areaParams!=""){
					nbParkings--; // to ignore the area element at the end of the json
				}

				console.log(out);
				
				for(let i=0; i<nbParkings; i++){
					let parking = {
						capacity:{value:0,approx:true}, 
						fee:getFee(out.elements[i].tags), 
						surface:0, 
						address:"",
						distance:0,
						pos:{lat:0.0,lon:0.0},
						paymentMethod:{cash:"", credit_card:"", coins:""}
					};
					
					if(out.elements[i].type != "node"){
						let lonDiff = out.elements[i].bounds.maxlon -out.elements[i].bounds.minlon;
						let latDiff = out.elements[i].bounds.maxlat -out.elements[i].bounds.minlat;
						parking.pos.lat = (out.elements[i].bounds.maxlat + out.elements[i].bounds.minlat) / 2;
						parking.pos.lon = (out.elements[i].bounds.maxlon + out.elements[i].bounds.minlon) / 2;
						let lat1 = parking.pos.lat;
						let lat2 = searchPos.lat;
						let lon1 = parking.pos.lon;
						let lon2 = searchPos.lon;
						let latWidth = distMeters(out.elements[i].bounds.minlat, out.elements[i].bounds.minlon, out.elements[i].bounds.maxlat, out.elements[i].bounds.minlon);
						let lonWidth = distMeters(out.elements[i].bounds.minlat, out.elements[i].bounds.minlon, out.elements[i].bounds.minlat, out.elements[i].bounds.maxlon);
						parking.surface = latWidth * lonWidth;
					}
					else{
						parking.pos.lat = out.elements[i].lat;
						parking.pos.lon = out.elements[i].lon;
					}
					parking.paymentMethod = getPaymentMethod(out.elements[i].tags);
					parking.capacity = getCapacity(out.elements[i].tags, parking.surface);
					parking.address = await getAddressFromPos(parking.pos);
					//console.log(parking);
					parking.distance = distMeters(parking.pos.lat, parking.pos.lon, searchPos.lat, searchPos.lon);
					if(parking.capacity.value>0){
						data.push(parking);
					}
				}
				return data;
			}
			catch(error){
				console.log("Error: could not fetch and parse data");
			}
		}
		
		function createTable(data){
			let table = document.getElementById("tableParkings");
			let tr = document.createElement('tr');
			addTh(tr, "adresse");
			addTh(tr, "nombre de places max");
			addTh(tr, "distance");
			addTh(tr, "payant");
			addTh(tr, "paiement en carte de crédit");
			addTh(tr, "paiement en billets");
			addTh(tr, "paiement en pièces");
			table.appendChild(tr);
			
			for(let element in data){
				let tr = document.createElement('tr');
				addTd(tr, data[element].address);
				addTd(tr, (data[element].capacity.approx ? "~":"") + data[element].capacity.value);
				addTd(tr, data[element].distance);
				addTd(tr, data[element].fee);
				addTd(tr, data[element].paymentMethod.credit_card);
				addTd(tr, data[element].paymentMethod.cash);
				addTd(tr, data[element].paymentMethod.coins);
				table.appendChild(tr);
			}
		}

		let buttonPos = document.getElementById("getUserLocation");
		let buttonSearchParam = document.getElementById("getSearchParams")
		let latText = document.getElementById("latitude");
		let longText = document.getElementById("longitude");
		
		buttonPos.addEventListener("click", () => {
			navigator.geolocation.getCurrentPosition((position) => {
				let lat = position.coords.latitude;
				let lon = position.coords.longitude;
				let areaParams = "";
				getParkingsData(lat,lon,areaParams).then((data) => {
					console.log(data);
					createTable(data);
				});
			});
		});

		buttonSearchParam.addEventListener("click", () => {
			navigator.geolocation.getCurrentPosition((position) => {
				let lat = position.coords.latitude;
				let lon = position.coords.longitude;

				// example: area[name="Paris 20e Arrondissement"];
				let areaParams = 'area[name="'+document.getElementById("searchBox").value+'"];';

				getParkingsData(lat,lon,areaParams).then((data) => {
					console.log(data);
					createTable(data);
				});
			});
		});
		
		// Used to get predict the number of free slots
		function testFreeSlotSim(){
			searchPos ={lat:49.0101759,lon:2.0421101};

			url = 
			'https://overpass-api.de/api/interpreter?data='
			+'[out:json];'
			+'(node[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
			+'node[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
			+'node[amenity="place_of_worship"](around:500,49.0101759,2.0421101);'
			+'node[shop](around:500,49.0101759,2.0421101);'
			+'node[airway="airport"](around:500,49.0101759,2.0421101);'
			+'node[healthcare](around:500,49.0101759,2.0421101);'
			+'node[historic](around:500,49.0101759,2.0421101);'
			+'node[leisure](around:500,49.0101759,2.0421101);'
			+'node[office](around:500,49.0101759,2.0421101);'
			+'node[tourism](around:500,49.0101759,2.0421101);'
			+'way[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
			+'way[amenity="place_of_worship"](around:500,49.0101759,2.0421101);'
			+'way[shop](around:500,49.0101759,2.0421101);'
			+'way[airway="airport"](around:500,49.0101759,2.0421101);'
			+'way[healthcare](around:500,49.0101759,2.0421101);'
			+'way[historic](around:500,49.0101759,2.0421101);'
			+'way[leisure](around:500,49.0101759,2.0421101);'
			+'way[office](around:500,49.0101759,2.0421101);'
			+'way[tourism](around:500,49.0101759,2.0421101););out 200;';
			
			fetch(url)
			.then((res) => res.json())
			.then((out) => {
				console.log(out);
				let probabilityFull = 0.0;

				//for(let i=0; i<out.elements.length; i++){
					//console.log(out.elements[i]);
				//}


			})
			.catch(error => { throw error });
			
			/*
			Create a variable that will start at 0 and increase if the probability that the parking is full increase. It'll be influenced by the following elements :
			- Display the accuracy of the prediction (e.g by using capacity.approx) ?
			- Get traffic data and/or city density -> nominatim (density) & TomTom (traffic)
			- Get current time and adjust the coefficients of the nodes and ways got just before (ex at night college will have a smaller weight and bar a higher one; in summer tourism will have a higher weight during holidays...)-
			- Check if there are other parkings nearby (it'll lower the probability, -> divide it by the quantity of parkings, or their capacity?)
			*/
		}
		
	</script>
	
	</body>
	</html>
	