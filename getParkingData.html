<!DOCTYPE html>
<html>
<head>
</head>
<body>
	

</body>
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
	<title>Accueil</title>
	<meta charset="UTF-8">
</head>
<body>
	<button id="getUserLocation">Trouver des parkings proches de votre position</button>
	<input id="searchBox" type="text" value="Paris 1er Arrondissement"></input>
	<button id="getSearchParams">Chercher un département ou une région entrée</button>
	<button onclick="testFreeSlotSim()">Test simulation emplacements libres</button>
	<table id="tableParkings">
	</table>
	<script>	
		function addTd(tr, content){
			var td = document.createElement('td');
			td.innerHTML = content;
			tr.appendChild(td);
		}
		function addTh(tr, content){
			var th = document.createElement('th');
			th.innerHTML = content;
			tr.appendChild(th);
		}

		function distMeters(lat1, lon1, lat2, lon2){
			//src : https://en.wikipedia.org/wiki/Haversine_formula
			const R = 6371e3; // Earth radius

			// Convert degrees to radians
			const phi1 = lat1 * Math.PI/180;
			const phi2 = lat2 * Math.PI/180;
			
			// Get lat and lon variation in radians
			const dphi = (lat2-lat1) * Math.PI/180;
			const dlambda = (lon2-lon1) * Math.PI/180;

			// Haversine function
			const h = Math.sin(dphi/2) ** 2 + Math.cos(phi1) * Math.cos(phi2) * (Math.sin(dlambda/2) ** 2);
			
			// Distance in meters = (Inverse haversine of h) * r = 2 * r * arcsin(sqrt(h))
			return 2 * R * Math.asin(Math.sqrt(h));
		}

		function getCapacity(data, surface){
			/*
			Surface -> capacity : https://www.dimensions.com/element/90-degree-parking-spaces-layouts
			400m² -> 12 slots
			*/
			let capacity = {value:0, approx:false};

			if(data.hasOwnProperty('capacity')){
				capacity.value = parseInt(data.capacity);
			}else{
				capacity.value = surface * (3/100);
				capacity.value = Math.round(capacity.value);
				capacity.approx = true;
			}
			if(capacity.value < 0){
				capacity.value = 0;
			}
			return capacity
		}

		function getFee(data){
			if(data.hasOwnProperty('fee')){
				return data.fee;
			} else{
				return ""
			}
		}

		function getPaymentMethod(data){
			let payment = {cash:"", credit_card:"", coins:""}
			if(data.hasOwnProperty('payment:cash')){
				payment.cash = data['payment:cash'];
			}
			if(data.hasOwnProperty('payment:credit_card')){
				payment.cash = data['payment:credit_card'];
			}
			if(data.hasOwnProperty('payment:coins')){
				payment.cash = data['payment:coins'];
			}
			return payment;
		}

		async function getAddressFromPos(pos){
			const response = await fetch("https://api.opencagedata.com/geocode/v1/json?q="+pos.lat+"+"+pos.lon+"&key=6ed462e0c4a54f39a14230ff783fc470")
			const json = await response.json();
			return json.results[0].formatted;
		}

		async function getParkingsData(latitude, longitude, areaParams){
			//let searchPos = {lat:49.023079,lon:2.047221};
			let searchPos = {lat:latitude,lon:longitude};
			let searchRadius = 600;
			
			// We only take nodes with the capacity tag because we don't have borders to get an surface used to get an approximation of this capacity

			let url ='';
			if(areaParams==""){
				url = 'https://overpass-api.de/api/interpreter?data=[out:json];(way[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');relation[amenity=parking](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+');node[amenity=parking][capacity](around:'+searchRadius+','+searchPos.lat+',' + searchPos.lon+'););out bb 200;';
			}
			else{
				url = 'https://overpass-api.de/api/interpreter?data=[out:json];('+areaParams+'way[amenity=parking](area);relation[amenity=parking](area);node[amenity=parking][capacity](area););out bb 200;';
			}
			
			let data = [];
		
			try{
				const response = await fetch(url)
				const out = await response.json();
				let nbParkings = out.elements.length;
				if(areaParams!=""){
					nbParkings--; // to ignore the area element at the end of the json
				}

				console.log(out);
				
				for(let i=0; i<nbParkings; i++){
					let parking = {
						capacity:{value:0,approx:true}, 
						fee:getFee(out.elements[i].tags), 
						surface:0, 
						address:"",
						distance:0,
						pos:{lat:0.0,lon:0.0},
						paymentMethod:{cash:"", credit_card:"", coins:""}
					};
					
					if(out.elements[i].type != "node"){
						let lonDiff = out.elements[i].bounds.maxlon -out.elements[i].bounds.minlon;
						let latDiff = out.elements[i].bounds.maxlat -out.elements[i].bounds.minlat;
						parking.pos.lat = (out.elements[i].bounds.maxlat + out.elements[i].bounds.minlat) / 2;
						parking.pos.lon = (out.elements[i].bounds.maxlon + out.elements[i].bounds.minlon) / 2;
						let lat1 = parking.pos.lat;
						let lat2 = searchPos.lat;
						let lon1 = parking.pos.lon;
						let lon2 = searchPos.lon;
						let latWidth = distMeters(out.elements[i].bounds.minlat, out.elements[i].bounds.minlon, out.elements[i].bounds.maxlat, out.elements[i].bounds.minlon);
						let lonWidth = distMeters(out.elements[i].bounds.minlat, out.elements[i].bounds.minlon, out.elements[i].bounds.minlat, out.elements[i].bounds.maxlon);
						parking.surface = latWidth * lonWidth;
					}
					else{
						parking.pos.lat = out.elements[i].lat;
						parking.pos.lon = out.elements[i].lon;
					}
					parking.paymentMethod = getPaymentMethod(out.elements[i].tags);
					parking.capacity = getCapacity(out.elements[i].tags, parking.surface);
					parking.address = await getAddressFromPos(parking.pos);
					//console.log(parking);
					parking.distance = distMeters(parking.pos.lat, parking.pos.lon, searchPos.lat, searchPos.lon);
					if(parking.capacity.value>0){
						data.push(parking);
					}
				}
				return data;
			}
			catch(error){
				console.log("Error: could not fetch and parse data");
			}
		}
		
		function createTable(data){
			let table = document.getElementById("tableParkings");
			let tr = document.createElement('tr');
			addTh(tr, "adresse");
			addTh(tr, "nombre de places max");
			addTh(tr, "distance");
			addTh(tr, "payant");
			addTh(tr, "paiement en carte de crédit");
			addTh(tr, "paiement en billets");
			addTh(tr, "paiement en pièces");
			table.appendChild(tr);
			
			for(let element in data){
				let tr = document.createElement('tr');
				addTd(tr, data[element].address);
				addTd(tr, (data[element].capacity.approx ? "~":"") + data[element].capacity.value);
				addTd(tr, data[element].distance);
				addTd(tr, data[element].fee);
				addTd(tr, data[element].paymentMethod.credit_card);
				addTd(tr, data[element].paymentMethod.cash);
				addTd(tr, data[element].paymentMethod.coins);
				table.appendChild(tr);
			}
		}

		let buttonPos = document.getElementById("getUserLocation");
		let buttonSearchParam = document.getElementById("getSearchParams")
		let latText = document.getElementById("latitude");
		let longText = document.getElementById("longitude");
		
		buttonPos.addEventListener("click", () => {
			navigator.geolocation.getCurrentPosition((position) => {
				let lat = position.coords.latitude;
				let lon = position.coords.longitude;
				let areaParams = "";
				getParkingsData(lat,lon,areaParams).then((data) => {
					console.log(data);
					createTable(data);
				});
			});
		});

		buttonSearchParam.addEventListener("click", () => {
			navigator.geolocation.getCurrentPosition((position) => {
				let lat = position.coords.latitude;
				let lon = position.coords.longitude;

				// example: area[name="Paris 20e Arrondissement"];
				let areaParams = 'area[name="'+document.getElementById("searchBox").value+'"];';

				getParkingsData(lat,lon,areaParams).then((data) => {
					console.log(data);
					createTable(data);
				});
			});
		});
		
		// Used to get predict the number of free slots

		async function fetchNearbyElements(pos, params, weightValue){
			url = 'https://overpass-api.de/api/interpreter?data=[out:json];(node'+params+'(around:500,'+pos.lat+','+pos.lon+');way'+params+'(around:500,'+pos.lat+','+pos.lon+');relation'+params+'(around:500,'+pos.lat+','+pos.lon+'););out count;';
			return fetch(url).then((res) => res.json()).then((out) => {
				let result = {weight:weightValue, count:out.elements[0].tags.total};
				return result;
			}).catch(error => { throw error });
		}

		async function getCityName(pos){
			const response = await fetch("https://api.opencagedata.com/geocode/v1/json?q="+pos.lat+"+"+pos.lon+"&key=6ed462e0c4a54f39a14230ff783fc470&limit=1")
			const json = await response.json();
			return json.results[0].components.city;
		}

		async function getCityPopulation(pos){			
			const city = await getCityName(pos);
			const response = await fetch('https://nominatim.openstreetmap.org/search.php?city="'+city+'"&format=json&extratags=1');
			const json = await response.json();
			return json [0].extratags.population;
		}

		//holidays ratio : 0 means that the date has no influence whereas 1 means that this place is only open during holidays. Values between 0 and 1 are accepted and gives the increase rate depending on if we are during holidays or not

		function sigmoid(x) {
			return 1 / (1 + Math.exp((1-x)/2));
		}

		function getTimePeriod(hour){

			/*
			9 - 11 morning
			11 - 14 noon
			14 - 18 afternoon
			18 - 21 evening
			21 - 3 night
			*/
			
			if(hour>=9){
				if(hour>=11){
					if(hour>=14){
						if(hour>=18){
							if(hour>=21){
								return "night";
							}
							else{
								return "evening";
							}
						}
						else{
							return "afternoon";
						}
					}
					else{
						return "noon";
					}
				}
				else{
					return "morning";
				}
			} else if(hour<=3){
				return "night";
			} else{
				return "ignore";
			}
		}

		function isHolidays(date){
			if((date.month==10 && date.day>=21)
			|| (date.month==11 && date.day<7)
			|| (date.month==12 && date.day>=17)
			|| (date.month==1 && date.day<3)
			|| (date.month==2 && date.day>=18)
			|| (date.month==3 && date.day<6)
			|| (date.month==4 && date.day>=22)
			|| (date.month==5 && date.day<9)
			|| (date.month==7 && date.day>=8)
			|| (date.month==8)){
				return true;
			}
			return false;
		}

		function getWeight(population, currentDate, holidays_ratio, opening_hours, importance){
			let weight = importance;
						
			if(opening_hours[getTimePeriod(currentDate.hour)] == false){
				weight+=0.1*importance;
			}

			if(isHolidays(currentDate)){
				if(holidays_ratio>0.0)
					weight+=importance*holidays_ratio;
			} else if(holidays_ratio>0.0){
				weight*=(1-holidays_ratio);
			}
	
			weight += (population/1000000);

			return sigmoid(weight);
		}

		async function testFreeSlotSim(){
			let searchPos ={lat:49.0101759,lon:2.0421101};
			/*
			+'(node[amenity~"^(restaurant|bar|cafe|fast_food|food_court|college|kindergarten|library|music_school|school|university|bank|clinic|dentist|doctors|hospital|pharmacy|veterinary|arts_centre|casino|cinema|community_centre|conference_centre|events_venue|exhibition_center|music_venue|planetarium|theatre|courthouse|police|post_depot|townhall|animal_boarding|internet_cafe|marketplace|place_of_worship|train_station)$"](around:500,49.0101759,2.0421101);'
			+'node[amenity="place_of_worship"](around:500,49.0101759,2.0421101);'
			+'node[shop](around:500,49.0101759,2.0421101);'
			+'node[airway="airport"](around:500,49.0101759,2.0421101);'
			+'node[healthcare](around:500,49.0101759,2.0421101);'
			+'node[historic](around:500,49.0101759,2.0421101);'
			+'node[leisure](around:500,49.0101759,2.0421101);'
			+'node[office](around:500,49.0101759,2.0421101);'
			+'node[tourism](around:500,49.0101759,2.0421101);'
			*/
			let promises = new Array();
			let date = new Date();
			let currentDate = {hour:date.getHours(), month:date.getMonth()};
			let cityPopulation = await getCityPopulation(searchPos);

			promises.push(fetchNearbyElements(searchPos, '[amenity~"^(restaurant|fast_food|food_court)$"]', getWeight(cityPopulation, currentDate, 0.0, {morning:false, noon:true, afternoon:false, evening:true, night:false}, 0.8)));
			promises.push(fetchNearbyElements(searchPos, '[shop]', getWeight(cityPopulation, currentDate, 0.0, {morning:true, noon:true, afternoon:true, evening:true, night:false}, 0.8)));

			data = await Promise.all(promises);

			console.log(data);
			//console.log(promises.get('shop'));

			let probabilityFull = 0.0;
			
			/*
			Create a variable that will start at 0 and increase if the probability that the parking is full increase. It'll be influenced by the following elements :
			- Display the accuracy of the prediction (e.g by using capacity.approx) ?
			- Get traffic data and/or city density -> nominatim (density) & TomTom (traffic)
			- Get current time and adjust the coefficients of the nodes and ways got just before (ex at night college will have a smaller weight and bar a higher one; in summer tourism will have a higher weight during holidays...)-
			- Check if there are other parkings nearby (it'll lower the probability, -> divide it by the quantity of parkings, or their capacity?)
			*/
		}
		
	</script>
	
	</body>
	</html>
	